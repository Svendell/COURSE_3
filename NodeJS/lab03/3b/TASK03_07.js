/*
22. Перепишите код со скриншота ниже и выполните его. Объясните полученный результат.
23. На примере этого кода объясните, как работает Event Loop.
*/

function f1(){
    console.log('f1');
}
        
function f2(){
     console.log('f2');
}
        
function f3(){
    console.log('f3');
}
        
function main(){
    console.log('main');
    //mac     - выполняются по одной за один проход цикла 
    setTimeout(f1, 50);
    setTimeout(f3, 50);
    //mic - на каждом проходе цикл выполняет все накопившееся.
    new Promise((resolve, reject) => 
        resolve('right after f1 and f3')
    ).then(resolve => console.log(resolve));
        
    new Promise((resolve, reject) => 
        resolve('Promise after Promise')
    ).then(resolve => console.log(resolve));
        
    f2();
}
        
main();

























/*
Определение функций f1, f2, f3:

f1, f2, и f3 - это обычные функции, каждая из которых выводит сообщение в консоль.
Определение функции main:

main - это функция, которая является точкой входа в программу. Она выводит сообщение "main" в консоль.
Внутри функции main происходит следующее:

В строках с комментариями //mac и //mic, вызываются асинхронные операции с использованием setTimeout и Promise.
setTimeout(f1, 50):

Эта строка создает асинхронный таймер с задержкой 50 миллисекунд, после чего вызывает функцию f1. Таким образом, функция f1 будет выполнена после 50 миллисекунд.
setTimeout(f3, 50):

Аналогично предыдущей строке, эта строка создает асинхронный таймер с задержкой 50 миллисекунд и вызывает функцию f3. Это также выполнится через 50 миллисекунд.
new Promise(...).then(...):

Этот код создает два Promise-объекта и немедленно их разрешает (resolved) с переданными значениями. Затем он присоединяет обработчики .then, которые выводят сообщения в консоль после успешного разрешения Promise-ов.
f2():

Вызывается функция f2, которая выводит сообщение "f2" в консоль.
Вызов main():

Наконец, функция main() вызывается из главного кода. Она становится точкой входа в программу, и все операции внутри main начинают выполняться.
Последовательность выполнения будет следующей:

"main" будет выведено в консоль.
Затем сработает таймер с функцией f1, и "f1" будет выведено в консоль после 50 миллисекунд.
Сработает таймер с функцией f3, и "f3" будет выведено в консоль также через 50 миллисекунд.
Промисы разрешатся немедленно, и их .then обработчики выведут сообщения в консоль.
"f2" будет немедленно выведено в консоль, так как это обычная синхронная функция.
*/
/*
Там кароче мейн в стек кладется,
потом setTimeoutы в очередь и промисв в очередь, ф2 в стек
И выполняется потом сначала мейн потом ф2
 потом промисв из очереди и потом таймауты





async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();

async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1

async function f() {
  return 1;
}

f().then(alert); // 1





new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});


*/